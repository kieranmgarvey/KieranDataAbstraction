/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package csci2320;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Random;
import java.util.Scanner;

/**
 * DO NOT EDIT THIS FILE!
 * Main application. I'm putting my code for the automated testing in here. Do not modify this
 * code. If you change this, you will fail the auto-grading.
 */
public class App {
    public static interface DistFunction {
        int distance(List<List<Integer>> graph, int start, int end);
    }

    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String testType = input.nextLine();
        switch (testType) {
            case "stack":
                ioTestArrayStack(input);
                break;
            case "queue":
                ioTestArrayQueue(input);
                break;
            case "gbfsshort":
                ioTestGraph(input, GraphSearch::bfsShortestPath);
                break;
            case "mbfsshort":
                ioTestMaze(input, GraphSearch::bfsShortestPath);
                break;
            case "iorpc":
                ioTestRPC(input);
                break;
            case "rpc":
                randomTestRPC(input);
                break;
            case "speed":
                SpeedTest.run();
        }
        input.close();
    }

    static void ioTestArrayStack(Scanner input) {
        int numOps = Integer.parseInt(input.nextLine());
        var stack = new ArrayStack<String>();
        for (int op = 0; op < numOps; ++op) {
            String[] line = input.nextLine().split(" +");
            switch (line[0]) {
                case "a":
                    stack.push(line[1]);
                    break;
                case "r":
                    stack.pop();
                    break;
                case "p":
                    System.out.println(stack.peek());
                    break;
                case "e":
                    System.out.println(stack.isEmpty());
                    break;
            }
        }
    }

    static void ioTestArrayQueue(Scanner input) {
        int numOps = Integer.parseInt(input.nextLine());
        var queue = new ArrayQueue<String>();
        for (int op = 0; op < numOps; ++op) {
            String[] line = input.nextLine().split(" +");
            switch (line[0]) {
                case "a":
                    queue.enqueue(line[1]);
                    break;
                case "r":
                    queue.dequeue();
                    break;
                case "p":
                    System.out.println(queue.peek());
                    break;
                case "e":
                    System.out.println(queue.isEmpty());
                    break;
            }
        }
    }

    static List<List<Integer>> readGraph(Scanner input) {
        int numVertices = Integer.parseInt(input.nextLine());
        List<List<Integer>> graph = new ArrayList<List<Integer>>();
        for (int i = 0; i < numVertices; ++i) {
            String line = input.nextLine().trim();
            if (line.isEmpty()) {
                graph.add(new ArrayList<Integer>());
            } else {
                graph.add(Arrays.stream(line.split(" +")).map(s -> Integer.parseInt(s)).toList());
            }
        }
        return graph;
    }

    static MazeToGraph.GraphAndLocMap readMaze(Scanner input) {
        int rows = Integer.parseInt(input.nextLine());
        int[][] maze = new int[rows][];
        for (int i = 0; i < rows; ++i) {
            maze[i] = input.nextLine().chars().map(c -> c - '0').toArray();
        }
        return MazeToGraph.mazeToAdjacencyList(maze);
    }

    static void runTest(List<List<Integer>> graph, Scanner input, DistFunction distFunc) {
        int testCases = Integer.parseInt(input.nextLine());
        for (int i = 0; i < testCases; ++i) {
            int start = input.nextInt();
            int end = input.nextInt();
            System.out.println(distFunc.distance(graph, start, end));
        }
    }

    static void runMazeTest(MazeToGraph.GraphAndLocMap gl, Scanner input, DistFunction distFunc) {
        int testCases = Integer.parseInt(input.nextLine());
        var locMap = gl.locMap();
        for (int i = 0; i < testCases; ++i) {
            int startRow = input.nextInt();
            int startCol = input.nextInt();
            var start = locMap.get(new MazeToGraph.MazeLocation(startRow, startCol));
            int endRow = input.nextInt();
            int endCol = input.nextInt();
            var end = locMap.get(new MazeToGraph.MazeLocation(endRow, endCol));
            System.out.println(distFunc.distance(gl.graph(), start, end));
        }
    }

    static void ioTestGraph(Scanner input, DistFunction distFunc) {
        List<List<Integer>> graph = readGraph(input);
        runTest(graph, input, distFunc);
    }

    static void ioTestMaze(Scanner input, DistFunction distFunc) {
        var gl = readMaze(input);
        runMazeTest(gl, input, distFunc);
    }

    static void ioTestRPC(Scanner input) {
        int numTests = Integer.parseInt(input.nextLine());
        for (int i = 0; i < numTests; ++i) {
            String test = input.nextLine();
            System.out.println(test);
            String vars = input.nextLine();
            System.out.println(vars);
            HashMap<String, Double> varMap = new HashMap<>();
            if (!vars.isEmpty()) {
                for (String varPair: vars.split(" *; *")) {
                    String[] keyVal = varPair.split(" +");
                    varMap.put(keyVal[0], Double.parseDouble(keyVal[1]));
                }
            }
            System.out.println(RPCalc.eval(test, varMap));
        }
    }

    static void randomTestRPC(Scanner input) {
        Random rand = new Random(input.nextInt());
        int size = input.nextInt();
        HashMap<String, Double> varMap = new HashMap<>();
        for (char c = 'a'; c <= 'z'; c++) {
            varMap.put(Character.toString(c), rand.nextDouble());
        }
        int stack = 0;
        StringBuilder sb = new StringBuilder();
        String[] ops = {"+ ", "- ", "* ", "/ "};
        for (int i = 0; i < size || stack > 1; ++i) {
            if (i >= size || (stack >= 2 && rand.nextDouble() < 0.3)) {
                sb.append(ops[rand.nextInt(ops.length)]);
                stack -= 1;
            } else {
                stack += 1;
                if (rand.nextDouble() < 0.5) {
                    sb.append(String.format("%1.3f", rand.nextDouble()) + " ");
                } else {
                    sb.append((char)('a' + rand.nextInt(26)) + " ");
                }
            }
        }
        String test = sb.toString().trim();
        System.out.println(test);
        System.out.printf("%1.3f", RPCalc.eval(test, varMap));
    }
}
