/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package csci2320;

import java.util.HashSet;
import java.util.Optional;
import java.util.Random;
import java.util.Scanner;
import java.util.Set;

public class App {
    static record IndexValuePair(int index, int value) {}

    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            String testType = sc.next();
            if (testType.equals("speed")) {
                SpeedTest.run();
                return;
            }
            Random rand = new Random(sc.nextLong());
            int size1 = sc.nextInt();
            int size2 = sc.nextInt();
            switch (testType) {
                case "basics":
                    System.out.println("Get Set 1");
                    testGetSet(size1, rand);
                    System.out.println("Get Set 2");
                    testGetSet(size2, rand);
                    System.out.println("Remove 1");
                    testRemove(size1, rand);
                    System.out.println("Remove 2");
                    testRemove(size2, rand);
                    System.out.println("Insert 1");
                    testInsert(size1, rand);
                    System.out.println("Insert 2");
                    testInsert(size2, rand);
                    break;
                case "higher-order":
                    System.out.println("Map 1");
                    testMap(size1, rand);
                    System.out.println("Filter 1");
                    testFilter(size1, rand);
                    System.out.println("Map 2");
                    testMap(size2, rand);
                    System.out.println("Filter 2");
                    testFilter(size2, rand);
                    System.out.println("Take");
                    testTake(size2, rand);
                    System.out.println("Drop");
                    testDrop(size2, rand);
                    System.out.println("Find");
                    testFind(size2, rand);
                    System.out.println("Fold");
                    testFold(size2, rand);
                    System.out.println("Mapped");
                    testMapped(size2, rand);
                    System.out.println("Filtered");
                    testFiltered(size2, rand);
                    System.out.println("Keep");
                    testKeep(size2, rand);
                    System.out.println("Removed");
                    testRemoved(size2, rand);
                    break;
            }
        }
    }

    static DLinkedSeq<Integer> buildSeq(int size, Random rand) {
        DLinkedSeq<Integer> ret = new DLinkedSeq<>();
        for (int i = 0; i < size; ++i) ret.add(rand.nextInt());
        return ret;
    }

    static void printSeqSums(Seq<Integer> seq) {
        int sum = 0;
        for (int i: seq) sum += i;
        System.out.println(sum);
    }

    static void testGetSet(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        int iters = Math.min(rand.nextInt(10)+10, seq.size() / 3);
        DLinkedSeq<IndexValuePair> pairs = new DLinkedSeq<>();
        Set<Integer> used = new HashSet<>();
        for (int i = 0; i < iters; ++i) {
            int index = rand.nextInt(seq.size());
            while (used.contains(index)) index = rand.nextInt(seq.size());
            used.add(index);
            int value = rand.nextInt();
            pairs.add(new IndexValuePair(index, value));
            seq.set(index, value);
        }
        for (IndexValuePair ivp: pairs) {
            if (ivp.value != seq.get(ivp.index)) {
                System.out.println("set-get pair failed " + ivp.value + " " + ivp.index + " " + seq.get(ivp.index));
                return;
            }
        }
        printSeqSums(seq);
    }

    static void testRemove(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        int iters = seq.size() / 3;
        for (int i = 0; i < iters; ++i) {
            int len = seq.size();
            int index = rand.nextInt(seq.size() - 2) + 1;
            int before = seq.get(index-1);
            int at = seq.get(index);
            int after = seq.get(index+1);
            int removed = seq.remove(index);
            if (removed != at) {
                System.out.println("Removed value doesn't match the get.");
                return;
            }
            if (seq.size() != len-1) {
                System.out.println("Size didn't decrease by one on remove.");
                return;
            }
            if (seq.get(index-1) != before) {
                System.out.println("Value before changed on remove.");
                return;
            }
            if (seq.get(index) != after) {
                System.out.println("Value after not moved down on remove. " + seq.get(index) +" " + after);
                return;
            }
        }
        printSeqSums(seq);
    }

    static void testInsert(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        int iters = seq.size() / 3;
        for (int i = 0; i < iters; ++i) {
            int len = seq.size();
            int index = rand.nextInt(seq.size() - 2) + 1;
            int before = seq.get(index-1);
            int at = seq.get(index);
            int newValue = rand.nextInt();
            seq.insert(index, newValue);
            if (seq.size() != len+1) {
                System.out.println("Size didn't increase by one on insert.");
                return;
            }
            if (seq.get(index-1) != before) {
                System.out.println("Value before changed on insert.");
                return;
            }
            if (seq.get(index) != newValue) {
                System.out.println("Value at index not properly set on insert.");
                return;
            }
            if (seq.get(index+1) != at) {
                System.out.println("Value at not pushed back on insert.");
                return;
            }
        }
        printSeqSums(seq);
    }

    static void testMap(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        var seq2 = seq.map(i -> i/2);
        for (int i = 0; i < seq.size(); ++i) {
            if (seq2.get(i) != seq.get(i) / 2) {
                System.out.println("Division maps didn't match.");
                return;
            }
        }
        printSeqSums(seq2);
        var seq3 = seq.map(i -> "str:" + i);
        for (int i = 0; i < seq.size(); ++i) {
            if (!seq3.get(i).equals("str:" + seq.get(i))) {
                System.out.println("String maps didn't match. " + seq3.get(i) + "!= str:" + seq.get(i));
                return;
            }
        }
    }

    static void testFilter(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        var evens = seq.filter(i -> i % 2 == 0);
        int j = 0;
        for (int i = 0; i < seq.size(); ++i) {
            if (seq.get(i) % 2 == 0) {
                if (seq.get(i) != evens.get(j)) {
                    System.out.println("Filter match error.");
                    return;
                }
                j++;
            }
        }
        if (j != evens.size()) {
            System.out.println("Filter length mismatch.");
        }
        printSeqSums(evens);
    }

    static void testTake(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        Set<Integer> firstFew = new HashSet<>();
        int toTake = Math.min(seq.size()/2, 5+rand.nextInt(5));
        for (int i = 0; i < toTake; ++i) {
            firstFew.add(seq.get(i));
        }
        var seq2 = seq.takeWhile(i -> firstFew.contains(i));
        printSeqSums(seq2);
    }

    static void testDrop(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        Set<Integer> firstFew = new HashSet<>();
        int toTake = Math.min(seq.size()/2, 5+rand.nextInt(5));
        for (int i = 0; i < toTake; ++i) {
            firstFew.add(seq.get(i));
        }
        var seq2 = seq.dropWhile(i -> firstFew.contains(i));
        printSeqSums(seq2);
    }

    static void testFind(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        Optional<Integer> div5loc = seq.find(i -> i % 5 == 0);
        int j = 0;
        while(j < seq.size() && seq.get(j) % 5 != 0) ++j;
        if (div5loc.isPresent() && seq.get(j) != div5loc.get() || !div5loc.isPresent() && j < seq.size()) {
            System.out.println("Find failed % 5.");
        }

        final int bigVal = 1800000000;
        Optional<Integer> bigloc = seq.find(i -> i > bigVal);
        j = 0;
        while(j < seq.size() && seq.get(j) <= bigVal) ++j;
        if (bigloc.isPresent() && seq.get(j) != bigloc.get() || !bigloc.isPresent() && j < seq.size()) {
            System.out.println("Find failed for big.");
        }
        for (int i = 0; i < 4; ++i) {
            int value = rand.nextInt();
            Optional<Integer> loc = seq.find(k -> k == value);
            j = 0;
            while(j < seq.size() && seq.get(j) != value) ++j;
            if (loc.isPresent() && seq.get(j) != loc.get() || !loc.isPresent() && j < seq.size()) {
                System.out.println("Find failed for random.");
            }
        }
    }

    static void testFold(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        var sumL = 0L;
        for (int i: seq) sumL += i;
        var leftSum = seq.foldLeft(0L, (Long s, Integer i) -> s + i);
        var rightSum = seq.foldRight((Integer i, Long s) -> i + s, 0L);
        if (sumL != leftSum || !leftSum.equals(rightSum)) {
            System.out.println("Fold sums don't match. " + sumL + " " + leftSum + " " + rightSum);
        }
        var leftDiff = seq.foldLeft(0L, (Long d, Integer i) -> d - i);
        long diffL = 0L;
        for (int i = 0; i < seq.size(); ++i) diffL -= seq.get(i);
        if (leftDiff != diffL) {
            System.out.println("Fold left diffs don't match.");
        }
        var rightDiff = seq.foldRight((Integer i, Long d) -> i - d, 0L);
        long diffR = 0L;
        for (int i = seq.size()-1; i >= 0; --i) diffR = seq.get(i) - diffR;
        if (rightDiff != diffR) {
            System.out.println("Fold right diffs don't match.");
        }
        String stringcat = seq.foldLeft("", (s, i) -> s+i);
        int lenSum = 0;
        for (int i: seq) lenSum += Integer.toString(i).length();
        if (lenSum != stringcat.length()) {
            System.out.println("Fold to string wrong length.");
        }
    }

    static void testMapped(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        seq.mapped(i -> i / 2);
        printSeqSums(seq);
    }

    static void testFiltered(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        seq.filtered(i -> i % 2 == 0);
        printSeqSums(seq);
    }

    static void testKeep(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        Set<Integer> firstFew = new HashSet<>();
        int toTake = Math.min(seq.size()/2, 5+rand.nextInt(5));
        for (int i = 0; i < toTake; ++i) {
            firstFew.add(seq.get(i));
        }
        seq.keepWhile(i -> firstFew.contains(i));
        printSeqSums(seq);
    }

    static void testRemoved(int size, Random rand) {
        Seq<Integer> seq = buildSeq(size, rand);
        printSeqSums(seq);
        Set<Integer> firstFew = new HashSet<>();
        int toTake = Math.min(seq.size()/2, 5+rand.nextInt(5));
        for (int i = 0; i < toTake; ++i) {
            firstFew.add(seq.get(i));
        }
        seq.removeWhile(i -> firstFew.contains(i));
        printSeqSums(seq);
    }
}
